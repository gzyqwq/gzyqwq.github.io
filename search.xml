<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[codeforces / project Euler 泛做]]></title>
    <url>%2F2019%2F03%2F10%2Fcodeforces-project-Euler-%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[[TOC] 发现这个题库，很有意思，趁着还没有学习微积分，看不了书，赶快从头开始刷，所以都是一些简单的题目，即时简单，有一些结论还是很有意思的。 网上资料很少，有的找不到答案，所以只有硬着头皮做了。 PE 15一个网格图,只能向下，或者向右走,问从$(0,0)$到$(n,m)$到路径有多少条. 这里的结论是有$C_{n+m}^n$. 证明：从0,0到n,m会往下走n步,往右走m步，把路径看成一个长度为n+m的序列，往下走为0,往右走为1 有n个0,m个1,转化为有多少个不同的序列。 我们考虑从序列中选择0的方案数.就是$C_{n+m}^n$. PE 76这是一道很有意思的Partition Function P题目。 里面详细的讲解了如何使用数学的方法来解，不过全是英文，我没有看懂。 也可以使用$f[i][j]$表示以i结尾最后一段的和式j数的方案数. 然后发现可以使用前缀和优化，复杂度$O(n^2)$ 由于是DP,所以放一下代码仅供参考. 12345678910111213141516int main() &#123; f[0][0] = sum[0][0] = 1; for(int i = 1;i &lt;= 100;++ i) sum[0][i] = sum[0][i - 1]; int n = 100; for(int i = 1;i &lt;= n;++ i) &#123; for(int j = 1;j &lt;= i;++ j) &#123; f[i][j] = sum[i - j][j]; sum[i][j] = f[i][j]; &#125; for(int j = 2;j &lt;= 100;++ j) sum[i][j] += sum[i][j - 1]; &#125; ll Ans = 0; Ans = sum[100][99]; std::cout &lt;&lt; Ans; return 0;&#125; 从上面的链接中得知,有生成函数的解法。 PE 90一个trick , 显然可以用对数函数来比较大小 $log(a^b) = b*log(a)$ PE 577恩，调这道题做了一下午。 $f(i)$表示以i行为底的六边形造成的共线，然后就可以计算了 $$f(n) = f(n-1) + \sum_{s=1}^{\lfloor n/3\rfloor}s(n-3s+1)$$ PE 97一个trick ， mod， 乘法和加法满足 $(ab)\%mod = ((a\%mod) (b\%mod))\%mod$ $(a+b)\%mod = ((a\% mod) + (b\% mod) )\%mod$ 待做PE 601 PE 613 PE 493 PE 102 PE 618]]></content>
      <tags>
        <tag>题解</tag>
        <tag>题库-PE</tag>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE 577 Counting hexagons]]></title>
    <url>%2F2019%2F03%2F10%2FPE-577-Counting-hexagons%2F</url>
    <content type="text"><![CDATA[PE 577 Counting hexagons扣细节扣了30min，仔细观察了一会发现一个比较容易递推的式子 $f(i)$表示i行造成的六边形的数量。 就有递推式$$f(n) = f(n-1) + \sum_{s=1}^{\lfloor n/3\rfloor}s(n-3s+1)$$ 考虑这样一张图 我们考虑新增加一行会贡献多少，显然只会增加以该行为底边的六边形，然后枚举一个长度，考虑该长度下会贡献多少。 我们先来看一下小的情况,即长度为2的情况 我们会发现有一个性质：当位于中间的S边可以出现的话，那么一定可以形成三角形。 我们会发现,只有两边中间这一部分才能形成六边形，两边是不能形成的。 就是$n - 3 * i + 1$，需要注意的是对于在这个底边的每一个点都会造成$1$的贡献.所以要乘上$i$（猜的题意，被题意卡了好久，mmp） 1234567891011121314151617181920const int maxN = 10000000 + 7;long long f[maxN];int main() &#123; int n = 12345; f[3] = 1; for(int i = 4;i &lt;= n;++ i) &#123; f[i] = f[i - 1]; int tmp = i / 3; for(int j = 1;j &lt;= tmp;++ j) &#123; f[i] += (i - 3 * j + 1) * j; &#125; &#125; long long Sum = 0; for(int i = 1;i &lt;= n;++ i) Sum += f[i]; std::cout &lt;&lt; Sum; return 0;&#125;/*ans：265695031399260211*/]]></content>
      <tags>
        <tag>题解</tag>
        <tag>题库-PE</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A big dream in the cruel world]]></title>
    <url>%2F2019%2F03%2F10%2FA-big-dream-in-the-cruel-world%2F</url>
    <content type="text"><![CDATA[终于把这个东西搞好了，呼 我是Jih_Knight 熟悉我的人应该知道以前的id是sdgzy. 哈哈，我是要成为计数大王的男人.]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
